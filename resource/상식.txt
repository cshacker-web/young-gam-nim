<URI, URN 차이>
https://lambdaexp.tistory.com/39



<JWT 소개 및 구조>
https://mangkyu.tistory.com/55
https://sanghaklee.tistory.com/47
(access token, refresh token)
https://swalloow.github.io/implement-jwt
(jwt를 어디에 보관할 것인가?)
https://sjquant.tistory.com/22



<stateless vs stateful>
https://sanghaklee.tistory.com/47
https://5equal0.tistory.com/entry/StatefulStateless-Stateful-vs-Stateless-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-HTTP-%EB%B0%8F-REST
(Restful API란?)
https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html



<브라우저 렌더링 과정>
https://boxfoxs.tistory.com/408
https://yoonjaepark.github.io/2018-12-25/repaint-reflow
https://webclub.tistory.com/m/346




<NOSQL vs RDBMS>
https://siyoon210.tistory.com/130
http://eincs.com/2012/06/nosql-is-not-useful/
https://blog.voidmainvoid.net/230
https://soy.me/2015/10/24/persistence_layer/



<캐싱 - 태그>
https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9



<옵저버 패턴>
https://johng rib.github.io/wiki/observer-pattern/
(hot ? cold?)




<HTTP 1.0 1.1 2.0>
https://gompangs.tistory.com/entry/HTTP%EC%97%90-%EA%B4%80%ED%95%B4%EC%84%9C
(파이프라이닝, 지속연결)
https://jins-dev.tistory.com/entry/HTTP11-%EC%9D%98-HTTP-Pipelining-%EA%B3%BC-Persistent-Connection-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC
(http 2.0)
https://jins-dev.tistory.com/entry/HTTP2-%ED%8A%B9%EC%A7%95%EB%93%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC

(이게 설명 가장 좋다)
https://americanopeople.tistory.com/115



<TCP 3 handshake, 4handshake, SSL handshake >
https://goodgid.github.io/TCP-IP-3Way-4Way/
(ssl handshake)
https://www.tuwlab.com/ece/26967
(ssl 동작방식)
https://opentutorials.org/course/228/4894
https://www.youtube.com/user/egoing2/search?query=%EB%8C%80%EC%B9%AD%ED%82%A4

https://gmlwjd9405.github.io/2018/09/19/tcp-connection.html




<OOP in javascript>
(OOP 개념)
https://velog.io/@hkoo9329/OOPObject-Oriented-Programming-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%EB%9E%80
https://victorydntmd.tistory.com/117
(프로토타입 체이닝 - 상속, 클로저 - 캡슐화)
https://poiemaweb.com/js-object-oriented-programming





<this 바인딩>
http://jeonghwan-kim.github.io/2017/10/22/js-context-binding.html




<nginx 설정>

(80 => 443 리다이렉트)
https://rsec.kr/?p=182

(캐시 설정)
https://www.joinc.co.kr/w/man/12/nginx/static
https://goddaehee.tistory.com/171
https://whatisthenext.tistory.com/123
https://12bme.tistory.com/367
https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9
https://developer.mozilla.org/ko/docs/Learn/Common_questions/What_is_a_web_server

(로드 밸런싱)
https://kamang-it.tistory.com/entry/WebServernginxnginx%EB%A1%9C-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8B%B1-%ED%95%98%EA%B8%B0
https://www.lesstif.com/system-admin/nginx-load-balancing-35357063.html





<lazy loading>
https://web.dev/native-lazy-loading/
https://meetup.toast.com/posts/183




<React Native>
https://evanjin.dev/development/react-native-%EC%B0%B8%EA%B3%A0%EC%82%AC%ED%95%AD%EB%93%A4/



<실행컨텍스트>





<클로저>



<호이스팅>
https://evan-moon.github.io/2019/06/18/javascript-let-const/
https://ojava.tistory.com/144



<js에서의 원시값, 참조값>
https://weicomes.tistory.com/133



<JIT 컴파일러>
https://ko.wikipedia.org/wiki/JIT_%EC%BB%B4%ED%8C%8C%EC%9D%BC
https://jinbroing.tistory.com/108
(c++의 컴파일, java 컴파일 비교)
https://kldp.org/node/161220
https://www.youtube.com/watch?v=UzaGOXKVhwU
https://namu.wiki/w/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC




<HOC>
https://meetup.toast.com/posts/137



<ARP에 대해서>
https://bnzn2426.tistory.com/71
https://pmj0403.tistory.com/entry/IP%EC%A3%BC%EC%86%8C%EC%99%80-MAP%EC%A3%BC%EC%86%8C-%EB%91%98-%EB%8B%A4-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0



<JAVA JVM Stack & Heap>
https://www.youtube.com/watch?v=UzaGOXKVhwU




<이벤트리스너에서의 콜백>
https://blog.outsider.ne.kr/506
https://nesoy.github.io/articles/2017-05/Javascript-Closure




<Redux Thunk, Saga의 차이>
https://velog.io/@dongwon2/Redux-Thunk-vs-Redux-Saga%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4-%EB%B4%85%EC%8B%9C%EB%8B%A4-
https://gracefullight.dev/2017/12/06/Why-redux-saga/
https://medium.com/humanscape-tech/redux%EC%99%80-%EB%AF%B8%EB%93%A4%EC%9B%A8%EC%96%B4-thunk-saga-43bb012503e4
https://ideveloper2.tistory.com/53
https://meetup.toast.com/posts/114




<Redux의 원리>
https://meetup.toast.com/posts/111




<순수함수란?>
https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-20-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98

https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD



<함수형 프로그래밍이란?>
https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD



<useCallback, useMemo>
https://velog.io/@yejinh/useCallback%EA%B3%BC-React.Memo%EC%9D%84-%ED%86%B5%ED%95%9C-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94#%EC%A0%81%EC%9A%A9-%EC%BD%94%EB%93%9C



<DNS에 대하여>
https://blog.naver.com/shj1126zzang/90193677759



<nodejs에서 비밀번호 암호화 방식>
https://www.zerocho.com/category/NodeJS/post/593a487c2ed1da0018cff95d

https://jusths.tistory.com/158

(여기 내용 아주 좋다 salt 와 알고리즘 수행 시간 cost에 대한 이야기)
http://www.codeok.net/%ED%8C%A8%EC%8A%A4%EC%9B%8C%EB%93%9C%20%EB%B3%B4%EC%95%88%EC%9D%98%20%EA%B8%B0%EC%88%A0

장황한 이야기지만 요약하면 간단하다. 패스워드 암호화는 데이터베이스가 털릴 경우를 대비한 것이며, brute force 공격에 대비하기 위해 패스워드 암호화 알고리즘의 수행 시간을 조절할 수 있어야 하고, rainbow table에 방어하기 위해 랜덤 salt를 추가해야 한다는 것이다. 그리고 이런 조건을 갖춘 패스워드 암호화 알고리즘으로 pbkdf2, brcypt, scrypt 등이 있으므로 이런 건 그냥 쓰면 된다

With "salt round" they actually mean the cost factor. The cost factor controls how much time is needed to calculate a single BCrypt hash. The higher the cost factor, the more hashing rounds are done. Increasing the cost factor by 1 doubles the necessary time. The more time is necessary, the more difficult is brute-forcing.

The salt is a random value, and should differ for each calculation, so the result should hardly ever be the same, even for equal passwords.

The salt is usually included in the resulting hash-string in readable form. So with storing the hash-string you also store the salt. Have a look at this answer for more details.



<ACID, Isolation level>
https://feco.tistory.com/45
https://goodgid.github.io/ACID/
http://www.dbguide.net/db.db?cmd=view&boardUid=148216&boardConfigUid=9&boardIdx=138&boardStep=1



<GC>
https://mirinae312.github.io/develop/2018/06/04/jvm_gc.html
https://d2.naver.com/helloworld/1329





<싱글턴 패턴>

(자바)
https://velog.io/@kyle/%EC%9E%90%EB%B0%94-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4-Singleton-Pattern

(js)
https://niceman.tistory.com/30

public class RealPrinter implements Printer {
    	private static Printer printer = null;
    
    	private RealPrinter() {
    	}
    
    	public synchronized static Printer getInstance() {
    		if (printer == null)
    			printer = new RealPrinter();
    		return printer;
    	}
    
    	@Override
    	public void print(String input) {
    		System.out.println(input);
    	}
    }
    






<유니코드, utf8, utf16>
https://brownbears.tistory.com/167




<해시충돌>
https://preamtree.tistory.com/20
https://yjshin.tistory.com/entry/%EC%95%94%ED%98%B8%ED%95%99-%ED%95%B4%EC%8B%9C-%ED%95%A8%EC%88%98-%EC%9E%91%EC%84%B1-%EC%A4%91






<인터페이스, 추상 클래스 차이>
https://mygumi.tistory.com/257





<웹 워커란>
https://medium.com/@pks2974/web-worker-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-4ec90055aa4d

https://d2.naver.com/helloworld/2922312





<제너레이터 함수>
https://poiemaweb.com/es6-generator
https://www.zerocho.com/category/ECMAScript/post/579b34e3062e76a002648af5
https://github.com/jaeseokk/ui-block-demo/blob/master/demo/scheduler2/index.js
https://github.com/jaeseokk/chunk-scheduler/blob/master/src/index.ts

(제너레이터 함수는 별도의 Thread에서 실행되는 것이 아니다)
https://hacks.mozilla.org/2015/05/es6-in-depth-generators/



<이벤트루프>
https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/
https://meetup.toast.com/posts/89
https://ko.javascript.info/event-loop

브라우저는 이벤트를 감지할 수 있으며 이벤트 발생 시에는 통지해 준다. 이 과정을 통해 사용자와 웹페이지는 상호작용(Interaction)이 가
능하게 된다.
브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.
단일 쓰레드는 쓰레드가 하나뿐이라는 의미이며 이말은 곧 하나의 작업(task)만을 처리할 수 있다는 것을 의미한다. 하지만 실제로 동작하는 웹 애플리케이션은 많은 task가 동시에 처리되는 것처럼 느껴진다. 이처럼 자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프(Event Loop)이다.
https://poiemaweb.com/js-event

이벤트 루프가 별도의 스레드에서 실행되고 자바스크립트 실행은 어떤 큐에서 하나씩 꺼내와서 다른 곳에서 하는 것이 아니라 자바스크립트의 실행 자체가 이벤트 루프 안에서 수행되는 것이다.
https://evan-moon.github.io/2019/08/01/nodejs-event-loop-workflow/

이벤트 드리븐 => 이벤트 루프 필수
- 이벤트가 발생하였을때, 저장해둔 작업을 수행하는 방식 
- 이벤트 리스너에 미리 콜백함수를 저장해놓고, 입력된 이벤트에 따라 해당하는 작업을 수행한다
- 발생한 이벤트는 순차적으로 처리하며, 발생한 이벤트가 없다면, 대기한다. 
-이벤트 루프가 이벤트 처리 순서를 관리해준다. 

※참고 : 자바스크립트는 싱글스레드 기반에서 콜백이 실행될수 있는 이유는
Web환경에서 스레드를 제공해주는api환경을 제공해준다. 
( ex> Dom(Documnet), Ajax, setTimeOut )

https://namjackson.tistory.com/30
https://developer.mozilla.org/ko/docs/Web/JavaScript/EventLoop#Event_loop
https://medium.com/@arunrajeevan/understanding-the-event-loop-mechanism-in-nodejs-174f5070e184

(JS 엔진, 브라우저 엔진에 대해서)
https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-Event-Loop-Event-Queue-Call-Stack

(nodejs에서의 이벤트 드리븐에 대해 잘 나와있음)
https://medium.com/@vdongbin/node-js-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-single-thread-
event-driven-non-blocking-i-o-event-loop-ce97e58a8e21

이벤트루프는 메인스레드 겸 싱글스레드로서, 비즈니스 로직을 수행한다
따라서 이벤트루프가 블로킹되는 것은 만병의 근원이다. 예를들어 while(true) {} 가 중간에 있으면 nodejs웹서버는 요청조차 받지 못한다. 또한 GC조차 이벤트루프에서 돌고 있으니, 이벤트루프가 바쁘면(= cpu인텐시브 작업) 메모리가 부족해서 뻗을 것이다.

https://sjh836.tistory.com/149

one thread == one call stack == one thing at a time
concurrency & the event loop (one thing at a time, except not really)
브라우저는 기본적으로 1초에 60프레임, 화면을 매번 16ms마다 repaint하는게 이상적 .(render queue > callback queue)
16ms 마다 큐에 렌더가 들어가고 call stack이 비었을때만 실행된다
https://www.youtube.com/watch?v=8aGhZQkoFbQ

https://d2.naver.com/helloworld/59361
https://jamong-icetea.tistory.com/237

이벤트루프는 기본적으로 무한 루프이며, 콜스택에서 실행될 내용이 있는지 여부를 계속 확인합니다. 콜스택이 비어있으면, 콜스택으로 이동할 항목이 있는지 이벤트 큐를 검사합니다. 메서드가 존재하는 경우 해당 메서드를 콜스택으로 이동시키고 메서드가 실행됩니다.

node.js는 콜 스택, 이벤트 큐에 항상 명령을 대기시키지 않고 이벤트 리스너event listener를 통해 이벤트가 발생하면 콜백함수를 실행하는 방식을 사용한다. 예를 들어 서버에 접속하는 이벤트event를 듣는listen 이벤트 리스너event listener를 코딩하고 해당 이벤트가 발생하면 콜백함수를 실행한다

https://medium.com/@vdongbin/node-js-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC-single-thread-event-driven-non-blocking-i-o-event-loop-ce97e58a8e21
https://meetup.toast.com/posts/89




<V8>
https://evan-moon.github.io/2019/06/28/v8-analysis/





<JS의 프로토타입 패턴>
 프로토타입 패턴이란, 객체를 생성할 때 원본이 되는 객체를 복사해서 생성하는 패턴
객체(Object)는 현실의 사물을 프로그램에 반영한 것이다. 즉, 여러 개의 프로퍼티(특징)와 메소드(행위)를 가지고 현실의 사물을 흉내내는 존재인 것이다
클래스 기반 언어에서는 클래스를 생성하고 그 클래스를 사용하여 객체를 생성해야하지만, 자바스크립트는 간단한 문법만으로 객체를 생성할 수 있다.(리터럴하게) but 우리는 간단한 문법만으로 객체를 생성했다고 느끼지만 내부적으로는 객체를 생성하는 일련의 매커니즘이 작동하고 있다. 자바스크립트의 객체도 갑자기 혼자서 뿅 하고 생성되는 것이 아니라 분명히 뭔가를 사용해서 만들어내고 있다는 말이다. 답은 바로 함수(Function)이다. 이런 방식을 생성자(Constructor)를 사용하여 객체를 생성한다고 한다.

1. 프로토타입 패턴이란 객체를 생성할 때 원본 객체를 복제하여 생성하는 방법이다.
2. 자바스크립트는 객체를 생성할 때 프로토타입 패턴을 사용한다.
3. 자바스크립트는 객체를 생성할 때 함수를 사용한다.

그렇다면 evan 객체는 무엇으로부터 복제된 것일까? 간단하게 생각하면 User 함수라고 생각해볼수 있겠지만, 사실은 User 함수를 복제한 것이 아니라 User 함수의 프로토타입 객체를 복제한 것이다.
. 만약 객체를 생성하면서 함수를 복제했다면 생성된 객체는 object 타입이 아니라 function 타입이어야 하지 않겠는가?
하지만 evan 객체는 object 타입을 가지고 있다. 즉, 이 함수 자체가 아니라 다른 객체 타입의 무언가를 복제했다는 것이고, 그 원본 객체가 User 함수의 프로토타입 객체인 것이다.
필자는 User 함수의 프로토타입을 명시적으로 선언하지 않았지만, 자바스크립트는 함수가 생성될 때 자동으로 그 함수의 프로토타입 객체(Prototype Object)도 함께 생성하고 해당 함수의 prototype 프로퍼티에 연결해둔다.
그리고 이 프로토타입 객체는 함수를 사용해서 새로운 객체를 생성할 때 원본 객체 역할을 해줄 객체를 의미한다.

이때 User 함수가 생성되며 함께 생성된 User 함수의 프로토타입 객체를 프로토타입 프로퍼티(Prototype Property)라고 한다.
함수가 생성되며 함께 생성된 프로토타입 객체는 모두 constructor라는 프로퍼티를 가지고 있다. 그리고 이 프로퍼티에는 이 프로토타입 객체가 생성될 때 선언했던 함수가 들어있다.
생성된 객체가 자신의 원본 객체에 접근할 수 있는 프로퍼티가 바로 __proto__ 프로퍼티
 자바스크립트 내의 모든 객체는 원본 객체를 기반으로 복사되어 생성되었기 때문에, 자신의 원본 객체로 연결되어있는 프로토타입 링크 또한 모든 객체가 가지고 있다. 이때 이 링크가 담기는 프로퍼티가 __proto__ 프로퍼티이다.

String, Boolean, Array든 뭐가 됐든 자바스크립트 내에 존재하는 모든 것들은 바로 Object 함수의 프로토타입인 Object.prototype을 시작으로 해서 복제된다.


객체는 함수를 사용해서 만들어지고, 객체는 함수의 프로토타입 객체를 복제하여 생성된다
모든 객체는 자신이 어떤 원본 객체를 복제하여 생성된 것인지에 대한 정보를 가지고 있다

https://evan-moon.github.io/2019/10/23/js-prototype/


<JS의 OOP>

자바스크립트에서의 상속은 프로토타입 체인을 사용하여 구현하고, 캡슐화는 클로저를 사용해서 구현하게 되는데

새롭게 생성되는 객체들에게 프로퍼티나 메소드를 부여할 수 있는데, 첫 번째는 생성자 함수 내에서 this를 사용하여 선언하는 방법, 두 번째는 새롭게 생성되는 객체들이 복사할 원본 객체인 프로토타입 객체에 선언하는 방법이다.

이 방법은 일반적인 생성자의 사용 방법과 비슷해서 직관적으로 이해가 되는 편이다. 이때 생성자 함수 안의 this는 새롭게 생성된 객체를 의미하기 때문에, 함수 내에서 this를 통해 정의한 프로퍼티나 메소드는 이 생성자 함수를 사용하여 객체가 생성될 때마다 새롭게 정의된다.

그렇기 때문에 각 객체마다 고유한 프로퍼티를 부여하고 싶다면 원본 객체에 정의하는 것이 아니라, 생성자 함수 내에서 this를 사용하여 정의해야한다. 다시 말하지만 원본 객체에 정의한 프로퍼티나 메소드는 생성된 객체들 끼리 공유된다
이 프로토타입 룩업 과정은 객체의 프로퍼티나 메소드에 접근하는 그 순간마다 수행되기 때문에, 클래스가 정의될 때 모든 상속관계가 함께 평가되는 클래스 기반 언어의 상속과는 조금 다른 느낌이다.

https://evan-moon.github.io/2019/10/27/inheritance-with-prototype/
https://developer.mozilla.org/ko/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript





<네트워크 병목 현상>
	따라서 개발하면서 여러 국가를 대상으로 다국어 설정, 국가별 화면 분기 등을 고려하는 것은 물론, 국가별 네트워크 속도, 모바일 기기에 표시할 콘텐츠의 양, 에러 핸들링 등 이전보다 훨씬 더 많은 측면을 고민하게 되었습니다. 이런 고민을 바탕으로 한국처럼 인터넷 속도가 빠르지 않은 다른 나라의 사용자들도 최대한 빠르고 편하게 LINE의 서비스를 이용할 수 있도록 최적화하고 있습니다.
	 LINE에서는 기획 회의, 개발자 API 회의 등 여러 회의에 참여하게 되었고 자연스레 제 의견을 개진할 수 있는 기회도 많아졌습니다. 특히 해외 오피스에 있는 분들과 화상 회의를 많이 하는데요.
	하지만 LINE에서는 빌드, 배포 서버 설정을 직접 해볼 수 있었고, Node.js 기반의 웹 서버를 직접 운영하기도 했습니다.  그동안 프론트엔드 개발만 해오다가 백엔드 개발을 병행하니 훨씬 재밌기도 하고 더 넓은 영역을 배우는 것 같아서 개발자로서 스스로 성장하는 걸 느끼고 있습니다.




<크롬 아키텍처>
https://d2.naver.com/helloworld/2922312



<자바스크립트 프로토타입>
https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67

https://poiemaweb.com/js-object-oriented-programming



<arrow function. 화살표 함수의 this>
 화살표 함수의 this는 언제나 상위스코프의 this를 가르킴
https://poiemaweb.com/es6-arrow-function
https://pro-self-studier.tistory.com/17


<use strict란?>
그렇다면, ES6에서는 Strict Mode가 필요할까?
* ES6에서는 디폴트가 Strict Mode이기 때문에 사용할 필요가 없습니다.

https://ithub.tistory.com/162


<React Local State vs Redux State(store) 언제 어떤것을 사용해야 할까?>
https://kimch3617.tistory.com/entry/React-Local-State-vs-Redux-StateStore-%EC%96%B8%EC%A0%9C-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98




<react 구조>
https://blog.naver.com/backsajang420/221352603007
https://blog.naver.com/backsajang420/221368885149






<typescript, babel의 결합>
https://ui.toast.com/weekly-pick/ko_20181220/



<cors>
https://sjh836.tistory.com/93
https://brunch.co.kr/@adrenalinee31/1




<webpack>
자바스크립트 코드가 많아지면 하나의 파일로 관리하는데 한계가 있다. 그렇다고 여러개 파일을 브라우져에서 로딩하는 것은 그만큼 네트웍 비용을 치뤄야하는 단점이 있다. 뿐만 아니라 각 파일은 서로의 스코프를 침범하지 않아야 하는데 잘못 작성할 경우 변수 충돌의 위험성도 있다.

Webpack은 의존 관계에 있는 모듈들을 하나의 자바스크립트 파일로 번들링하는 모듈 번들러이다

babel
Webpack이 모듈을 번들링할 때 Babel을 사용하여 ES6+ 코드를 ES5 코드로 트랜스파일링하도록 babel-loader를 설치

babel-polyfill
Babel을 사용하여 ES6+ 코드를 ES5 이하로 트랜스파일링하여도 브라우저가 지원하지 않는 코드가 남아 있을 수 있다
ES6에서 추가된 Promise, Object.assign, Array.from 등

웹팩의 주요 네 가지 개념으로 Entry, Output, Loader, Plugin이 있다.



웹팩은 기본적으로 모듈 번들러다.
의존성 그래프에서 엔트리로 그래프의 시작점을 설정하면 웹팩은 모든 자원을 모듈로 로딩한 후 아웃풋으로 묶어준다. 로더로 각 모듈별로 바벨, 사스변환 등의 처리하고 이 결과를 플러그인이 받아 난독화, 텍스트 추출 등의 추가 작업을 한다.


https://poiemaweb.com/es6-babel-webpack-2
http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html
https://velog.io/@hih0327/Webpack-%EA%B8%B0%EC%B4%88
http://jeonghwan-kim.github.io/js/2017/05/15/webpack.html



<MVC란>





<OOP의 solid 원칙?>




<TCP, UDP 차이>





<SEO 최적화>
react에서 핵심은 서버에서 렌더링이 가능한 라이브react-router-server를 통해 
https://velopert.com/3425
https://medium.com/@jinminkim_50502/seo-%EA%B2%80%EC%83%89-%EC%97%94%EC%A7%84-%EC%B5%9C%EC%A0%81%ED%99%94-b3613dfe666b
https://velog.io/@rjs1197/SSR%EA%B3%BC-CSR%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90



<Semantic HTML>
https://medium.com/@soeunlee/%EC%8B%9C%EB%A7%A8%ED%8B%B1%ED%95%98%EA%B2%8C-html%EC%9D%84-%EC%A7%A0%EB%8B%A4%EB%8A%94-%EA%B2%83-90612ffc988e


<CSS 전처리기>
https://kdydesign.github.io/2019/05/12/css-preprocessor/



<React 조화과정 & immutable 업데이트를 통한 avoiding>
 n-depth의 복잡한 자료구조에 대해서 deep-compare를 수행하면 오히려 배보다 배꼽이 더 큰 경우가 될 수 있기 때문에 shallow-compare로 제한하고 있다. React를 개발한다면 state나 props를 최대한 가볍게, 혹은 Immutable 객체를 사용하여 개발하는 것을 추천한다.
https://meetup.toast.com/posts/110
https://reactjs-kr.firebaseapp.com/docs/reconciliation.html



<FP 함수형 프로그래밍>
함수형 프로그래밍은 순수 함수(pure function) 를 조합하고 공유 상태(shared state), 변경 가능한 데이터(mutable data) 및 부작용(side-effects) 을 피하여 소프트웨어를 만드는 프로세스다. 함수형 프로그래밍은 명령형(imperative) 이 아닌 선언형(declarative) 이며 애플리케이션의 상태는 순수 함수를 통해 전달된다

합성 함수란 새로운 함수를 만들어거나 계산하기 위해 둘 이상의 함수를 조합하는 과정을 말한다. 함수형 프로그램은 여러 작은 순수 함수들로 이루어져있기 때문에 이 함수들을 연쇄적으로 또는 병렬로 호출해서 더 큰 함수를 만드는 과정으로 전체 프로그램을 구축해야 한다.

https://velog.io/@kyusung/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EC%95%BD
https://medium.com/@lazysoul/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-d881230f2a5e



<inner join vs outer join>
https://jetalog.net/28




<쿼리가 어떻게 작동하는지>







<암호화 방식 - 공개키, 비밀키>






<OAuth 1.0 / 1.1 / 2.0>